/*	WiiCamera.cpp - Arduino Library for WiiCamera Sensor  This work was derived from;  1)	Kako's excellent Japanese website http://www.kako.com/neta/2007-001/2007-001.html 2)	Steve Hobley 2009 - www.stephenhobley.com  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  	Sensor is conected to I2C port 	 	Variables: 		RawSonar : Raw Sonar data 		Sonar : Calculated Distance   (in cm units)  	Methods: 		Init() : Initialization of I2C  		Read() : Read sensor data and calculate  Range 		         This function is optimized so the main host don't need to wait 				 You can call this function in your main loop 				 It returns a 1 if there is new data.  	Internal functions: 		Calculate() : Calculate Range in real units   */// Includes //////////////////////////////////////////////////////////////#include "aaWiiCamera.h"#include <Arduino.h>#include <AP_HAL.h>#define WII_CAMERA_PORT 0x58extern const AP_HAL::HAL& hal;uint8_t  control2[2]    = {0x30,0x01};uint8_t  max2 [2]       = {0x06,0x90};uint8_t  gain2 [2]      = {0x08,0xC0};uint8_t  gainlimit2 [2] = {0x1A,0x40};uint8_t  mode2 [2]      = {0x33,0x33};uint8_t  last2 [2]      = {0x30,0x08};uint8_t *controlptr2 = &control2[0];uint8_t *maxptr2 = &max2[0];uint8_t *gainptr2 = &gain2[0];uint8_t *gainlimitptr2 = &gainlimit2[0];uint8_t *modeptr2 = &mode2[0];uint8_t *lastptr2 = &last2[0];// Private Methods //////////////////////////////////////////////////////////////void WiiCamera::Write2bytes(byte d1, byte d2){//rewrite this using hal.i2c//should take d1 and d2, write them on the wire, then delay for 10ms}// Constructors ////////////////////////////////////////////////////////////////WiiCamera::WiiCamera(){	WiiCamera_State = 0;		 	// Initial state	idx = 0;	blobcount = 0;	Blob[0].number = 1;	Blob[1].number = 2;	Blob[2].number = 3;	Blob[3].number = 4;}// Public Methods //////////////////////////////////////////////////////////////// init the Wii cameravoid WiiCamera::init(){  hal.i2c->IRCam_init(); 	  hal.scheduler->delay(100);  _i2c_sem = hal.i2c->get_semaphore();  if (!_i2c_sem->take(HAL_SEMAPHORE_BLOCK_FOREVER)) {      hal.scheduler->panic(PSTR("Failed to get HMC5843 semaphore"));  }      hal.i2c->setHighSpeed(false);  	  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, controlptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, lastptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, maxptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, gainptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, gainlimitptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, modeptr2);  hal.scheduler->delay(50);      _i2c_sem->give();  hal.scheduler->delay(1000);      WiiCamera_State = 1;				    // Ready to Read state}// Read the sensor. int WiiCamera::read(){	  uint8_t data = 0x36;  uint8_t*dataptr = &data;  uint8_t data_buf[16];  uint8_t*data_bufptr = &data_buf[0];  ///int idx=0;  int s;//if(WiiCamera_State==1)	// New Read request //{	// clear space for new data	//for (idx=0;idx<16;idx++) data_buf[idx]=0;	// index for data pointer	//idx = 0;	// Reset the blob counter	blobcount = 0;	//WiiCamera_State++;	// new state expects data // } // if (WiiCamera_State>=2)	// Waiting for first Data byte from a previous read request // {  //  WiiCamera_State++;		// new state, now reading data    hal.i2c->write((uint8_t)WII_CAMERA_PORT,1, dataptr);    hal.i2c->read((uint8_t)WII_CAMERA_PORT,16, data_bufptr);        _i2c_sem->give();    	// if we have 16 bytes of data	//if (idx >= 16)	//{		hal.console->printf_P(PSTR("We are in read mode: %d \n"),(int)blobcount);	    Blob[0].X= data_buf[1];        Blob[0].Y = data_buf[2];        s   = data_buf[3];        Blob[0].X+= (s & 0x30) <<4;        Blob[0].Y += (s & 0xC0) <<2;        Blob[0].Size = (s & 0x0F);		if (Blob[0].Size<15) blobcount++;        Blob[1].X = data_buf[4];        Blob[1].Y = data_buf[5];        s   = data_buf[6];        Blob[1].X += (s & 0x30) <<4;        Blob[1].Y += (s & 0xC0) <<2;        Blob[1].Size = (s & 0x0F);		if (Blob[1].Size<15) blobcount++;        Blob[2].X = data_buf[7];        Blob[2].Y = data_buf[8];        s   = data_buf[9];        Blob[2].X += (s & 0x30) <<4;        Blob[2].Y += (s & 0xC0) <<2;        Blob[2].Size = (s & 0x0F);		if (Blob[2].Size<15) blobcount++;        Blob[3].X = data_buf[10];        Blob[3].Y = data_buf[11];        s   = data_buf[12];        Blob[3].X += (s & 0x30) <<4;        Blob[3].Y += (s & 0xC0) <<2;        Blob[3].Size = (s & 0x0F);		if (Blob[3].Size<15) blobcount++;	//iCamera_State = 1;				// back to ready to Read state	//}	//if (WiiCamera_State>=10) WiiCamera_State = 1;	// Waited too long for data - back to ready to Read state// }return(blobcount);}#if 0/*---------------------------------------------------------*               IR Camera Control Loop             *----------------------------------------------------------*//// get_loiter_position_to_velocity - loiter position controller///     converts camera error to desired velocityvoid WiiCamera::get_loiter_position_to_velocity(float dt, float max_speed_cms){    Vector3f curr = _inav->get_position();    float dist_error_total;    float vel_sqrt;    float vel_total;    float linear_distance;      // the distace we swap between linear and sqrt.    float kP = _pid_pos_lat->kP();    // avoid divide by zero    if (kP <= 0.0f) {        desired_vel.x = 0.0;        desired_vel.y = 0.0;    }else{  		    	dist_error.x = camera_error_x;    	dist_error.y = camera_error_y;        linear_distance = _wp_accel_cms/(2.0f*kP*kP);        dist_error_total = safe_sqrt(dist_error.x*dist_error.x + dist_error.y*dist_error.y);        //_distance_to_target = dist_error_total;      // for reporting purposes        if( dist_error_total > 2.0f*linear_distance ) {            vel_sqrt = safe_sqrt(2.0f*_wp_accel_cms*(dist_error_total-linear_distance));            desired_vel.x = vel_sqrt * dist_error.x/dist_error_total;            desired_vel.y = vel_sqrt * dist_error.y/dist_error_total;        }else{            desired_vel.x = _pid_pos_lat->kP() * dist_error.x;            desired_vel.y = _pid_pos_lon->kP() * dist_error.y;        }        // ensure velocity stays within limits        vel_total = safe_sqrt(desired_vel.x*desired_vel.x + desired_vel.y*desired_vel.y);        if( vel_total > max_speed_cms ) {            desired_vel.x = max_speed_cms * desired_vel.x/vel_total;            desired_vel.y = max_speed_cms * desired_vel.y/vel_total;        }        // feed forward velocity request        desired_vel.x += _target_vel.x;        desired_vel.y += _target_vel.y;    }}/// get_loiter_velocity_to_acceleration - loiter velocity controller///    converts desired velocities in lat/lon directions to accelerations in lat/lon framevoid WiiCamera::get_loiter_velocity_to_acceleration(float vel_lat, float vel_lon, float dt){    const Vector3f &vel_curr = _inav->get_velocity();  // current velocity in cm/s    Vector3f vel_error;                         // The velocity error in cm/s.    float accel_total;                          // total acceleration in cm/s/s    // reset last velocity if this controller has just been engaged or dt is zero    if( dt == 0.0 ) {        desired_accel.x = 0;        desired_accel.y = 0;    } else {        // feed forward desired acceleration calculation        desired_accel.x = (vel_lat - _vel_last.x)/dt;        desired_accel.y = (vel_lon - _vel_last.y)/dt;    }    // store this iteration's velocities for the next iteration    _vel_last.x = vel_lat;    _vel_last.y = vel_lon;    // calculate velocity error    vel_error.x = vel_lat - vel_curr.x;    vel_error.y = vel_lon - vel_curr.y;    // combine feed foward accel with PID outpu from velocity error    desired_accel.x += _pid_rate_lat->get_pid(vel_error.x, dt);    desired_accel.y += _pid_rate_lon->get_pid(vel_error.y, dt);    // scale desired acceleration if it's beyond acceptable limit    accel_total = safe_sqrt(desired_accel.x*desired_accel.x + desired_accel.y*desired_accel.y);    if( accel_total > WPNAV_ACCEL_MAX ) {        desired_accel.x = WPNAV_ACCEL_MAX * desired_accel.x/accel_total;        desired_accel.y = WPNAV_ACCEL_MAX * desired_accel.y/accel_total;    }}/// get_loiter_acceleration_to_lean_angles - loiter acceleration controller///    converts desired accelerations provided in lat/lon frame to roll/pitch anglesvoid WiiCamera::get_loiter_acceleration_to_lean_angles(float accel_lat, float accel_lon){    float z_accel_meas = -GRAVITY_MSS * 100;    // gravity in cm/s/s    float accel_forward;    float accel_right;    // To-Do: add 1hz filter to accel_lat, accel_lon    // rotate accelerations into body forward-right frame    accel_forward = accel_lat*_cos_yaw + accel_lon*_sin_yaw;    accel_right = -accel_lat*_sin_yaw + accel_lon*_cos_yaw;    // update angle targets that will be passed to stabilize controller    _desired_roll = constrain_float(fast_atan(accel_right*_cos_pitch/(-z_accel_meas))*(18000/M_PI), -_lean_angle_max_cd, _lean_angle_max_cd);    _desired_pitch = constrain_float(fast_atan(-accel_forward/(-z_accel_meas))*(18000/M_PI), -_lean_angle_max_cd, _lean_angle_max_cd);}#endif