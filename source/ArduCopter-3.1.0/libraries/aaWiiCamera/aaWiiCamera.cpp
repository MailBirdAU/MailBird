/*	WiiCamera.cpp - Arduino Library for WiiCamera Sensor  This work was derived from;  1)	Kako's excellent Japanese website http://www.kako.com/neta/2007-001/2007-001.html 2)	Steve Hobley 2009 - www.stephenhobley.com  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  	Sensor is conected to I2C port 	 	Variables: 		RawSonar : Raw Sonar data 		Sonar : Calculated Distance   (in cm units)  	Methods: 		Init() : Initialization of I2C  		Read() : Read sensor data and calculate  Range 		         This function is optimized so the main host don't need to wait 				 You can call this function in your main loop 				 It returns a 1 if there is new data.  	Internal functions: 		Calculate() : Calculate Range in real units   */// Includes //////////////////////////////////////////////////////////////#include "aaWiiCamera.h"#include <Arduino.h>#include <AP_HAL.h>#define WII_CAMERA_PORT 0x58extern const AP_HAL::HAL& hal;uint8_t  control2[2]    = {0x30,0x01};uint8_t  max2 [2]       = {0x06,0x90};uint8_t  gain2 [2]      = {0x08,0xC0};uint8_t  gainlimit2 [2] = {0x1A,0x40};uint8_t  mode2 [2]      = {0x33,0x33};uint8_t  last2 [2]      = {0x30,0x08};uint8_t *controlptr2 = &control2[0];uint8_t *maxptr2 = &max2[0];uint8_t *gainptr2 = &gain2[0];uint8_t *gainlimitptr2 = &gainlimit2[0];uint8_t *modeptr2 = &mode2[0];uint8_t *lastptr2 = &last2[0];// Private Methods //////////////////////////////////////////////////////////////void WiiCamera::Write2bytes(byte d1, byte d2){//rewrite this using hal.i2c//should take d1 and d2, write them on the wire, then delay for 10ms}// Constructors ////////////////////////////////////////////////////////////////WiiCamera::WiiCamera(){	WiiCamera_State = 0;		 	// Initial state	idx = 0;	blobcount = 0;	Blob[0].number = 1;	Blob[1].number = 2;	Blob[2].number = 3;	Blob[3].number = 4;}// Public Methods //////////////////////////////////////////////////////////////// init the Wii cameravoid WiiCamera::init(){  hal.i2c->IRCam_init(); 	  hal.scheduler->delay(100);  _i2c_sem = hal.i2c->get_semaphore();  if (!_i2c_sem->take(HAL_SEMAPHORE_BLOCK_FOREVER)) {      hal.scheduler->panic(PSTR("Failed to get HMC5843 semaphore"));  }      hal.i2c->setHighSpeed(false);  	  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, controlptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, lastptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, maxptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, gainptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, gainlimitptr2);  hal.scheduler->delay(50);  hal.i2c->write((uint8_t)WII_CAMERA_PORT,2, modeptr2);  hal.scheduler->delay(50);      _i2c_sem->give();  hal.scheduler->delay(1000);      WiiCamera_State = 1;				    // Ready to Read state}// Read the sensor. int WiiCamera::read(){	  uint8_t data = 0x36;  uint8_t*dataptr = &data;  uint8_t data_buf[16];  uint8_t*data_bufptr = &data_buf[0];  int idx=0;  int s;if(WiiCamera_State==1)	// New Read request  {	// clear space for new data	for (idx=0;idx<16;idx++) data_buf[idx]=0;	// index for data pointer	idx = 0;	// Reset the blob counter	blobcount = 0;	WiiCamera_State++;	// new state expects data  }  if (WiiCamera_State>=2)	// Waiting for first Data byte from a previous read request  {    WiiCamera_State++;		// new state, now reading data    hal.i2c->write((uint8_t)WII_CAMERA_PORT,1, dataptr);    hal.i2c->read((uint8_t)WII_CAMERA_PORT,16, data_bufptr);        _i2c_sem->give();        hal.console->printf_P(PSTR("Ix1: %d"),(int)data_buf[0]);    hal.console->printf_P(PSTR("Iy1: %d\r\n"),(int)data_buf[1]);    hal.console->printf_P(PSTR("Ix2: %d"),(int)data_buf[2]);    hal.console->printf_P(PSTR("Iy2: %d\r\n"),(int)data_buf[3]);	// if we have 16 bytes of data	if (idx >= 16)	{	    Blob[0].X= data_buf[1];        Blob[0].Y = data_buf[2];        s   = data_buf[3];        Blob[0].X+= (s & 0x30) <<4;        Blob[0].Y += (s & 0xC0) <<2;        Blob[0].Size = (s & 0x0F);		if (Blob[0].Size<15) blobcount++;        Blob[1].X = data_buf[4];        Blob[1].Y = data_buf[5];        s   = data_buf[6];        Blob[1].X += (s & 0x30) <<4;        Blob[1].Y += (s & 0xC0) <<2;        Blob[1].Size = (s & 0x0F);		if (Blob[1].Size<15) blobcount++;        Blob[2].X = data_buf[7];        Blob[2].Y = data_buf[8];        s   = data_buf[9];        Blob[2].X += (s & 0x30) <<4;        Blob[2].Y += (s & 0xC0) <<2;        Blob[2].Size = (s & 0x0F);		if (Blob[2].Size<15) blobcount++;        Blob[3].X = data_buf[10];        Blob[3].Y = data_buf[11];        s   = data_buf[12];        Blob[3].X += (s & 0x30) <<4;        Blob[3].Y += (s & 0xC0) <<2;        Blob[3].Size = (s & 0x0F);		if (Blob[3].Size<15) blobcount++;		WiiCamera_State = 1;				// back to ready to Read state	}	if (WiiCamera_State>=10) WiiCamera_State = 1;	// Waited too long for data - back to ready to Read state }return(blobcount);}