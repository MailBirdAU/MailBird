/*	WiiCamera.cpp - Arduino Library for WiiCamera Sensor  This work was derived from;  1)	Kako's excellent Japanese website http://www.kako.com/neta/2007-001/2007-001.html 2)	Steve Hobley 2009 - www.stephenhobley.com  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  	Sensor is conected to I2C port 	 	Variables: 		RawSonar : Raw Sonar data 		Sonar : Calculated Distance   (in cm units)  	Methods: 		Init() : Initialization of I2C  		Read() : Read sensor data and calculate  Range 		         This function is optimized so the main host don't need to wait 				 You can call this function in your main loop 				 It returns a 1 if there is new data.  	Internal functions: 		Calculate() : Calculate Range in real units   */// Includes //////////////////////////////////////////////////////////////#include "aaWiiCamera.h"#include <Arduino.h>#include <Wire.h>#include <AP_HAL.h>extern const AP_HAL::HAL& hal;// Private Methods //////////////////////////////////////////////////////////////void WiiCamera::Write2bytes(byte d1, byte d2){//rewrite this using hal.i2c//should take d1 and d2, write them on the wire, then delay for 10ms}// Constructors ////////////////////////////////////////////////////////////////WiiCamera::WiiCamera(){	WiiCamera_State = 0;		 	// Initial state	idx = 0;	blobcount = 0;	Blob[0].number = 1;	Blob[1].number = 2;	Blob[2].number = 3;	Blob[3].number = 4;}// Public Methods //////////////////////////////////////////////////////////////// init the Wii cameravoid WiiCamera::init(){  IRsensorAddress = 0xB0;					// i2c address  IRslaveAddress = IRsensorAddress >> 1;	// This results in 0x21 as the address to pass to TWI	hal.scheduler->delay(10);	_i2c_sem = hal.i2c->get_semaphore();	    if (!_i2c_sem->take(HAL_SEMAPHORE_BLOCK_FOREVER)) {	        hal.scheduler->panic(PSTR("Failed to get HMC5843 semaphore"));	    }	    hal.scheduler->delay(50);	    _i2c_sem->give();  // Wii IR sensor initialize  // http://wiki.wiimoteproject.com/IR_Sensor  // Level 1: p0 = 0x72, p1 = 0x20, p2 = 0x1F, p3 = 0x03  // Level 2: p0 = 0xC8, p1 = 0x36, p2 = 0x35, p3 = 0x03  // Level 3: p0 = 0xAA, p1 = 0x64, p2 = 0x63, p3 = 0x03  // Level 4: p0 = 0x96, p1 = 0xB4, p2 = 0xB3, p3 = 0x04  // Level 5: p0 = 0x96, p1 = 0xFE, p2 = 0xFE, p3 = 0x05  // p0: MAXSIZE: Maximum blob size. Wii uses values from 0x62 to 0xc8  // p1: GAIN: Sensor Gain. Smaller values = higher gain  // p2: GAINLIMIT: Sensor Gain Limit. Must be less than GAIN for camera to function. No other effect?  // p3: MINSIZE: Minimum blob size. Wii uses values from 3 to 5	  Write2bytes(0x30,0x01);				//Control byte, allows modification of settings  Write2bytes(0x06,0x90);				// MAXSIZE - Maximum blob size. Wii uses values from 0x62 to 0xc8.  Write2bytes(0x08,0xC0);				// GAIN - Sensor Gain. Smaller values = higher gain. Numerical gain is proportional to 1/2^(n/16) for n<0x40  Write2bytes(0x1A,0x40);				// GAINLIMIT - Sensor Gain Limit. Must be less than GAIN for camera to function. No other effect?  Write2bytes(0x33,0x33);				// MODE - Camera mode  Write2bytes(0x30,0x08);				// was 2nd - suspect it really needs to be here  hal.scheduler->delay(50);  WiiCamera_State = 1;						// Ready to Read state}// Read the sensor. int WiiCamera::read(){  int data_buf[16];  int idx=0;  int s;if(WiiCamera_State==1)	// New Read request  {	// Set Wii Camera to correct data mode	//Write 0x36 to wire using hal.i2c    // request data from sensor    // not sure how to rewrite this Wire.requestFrom(IRslaveAddress, 16);	// clear space for new data	for (idx=0;idx<16;idx++) data_buf[idx]=0;	// index fo data pointer	idx = 0;	// Reset the blob counter	blobcount = 0;	WiiCamera_State++;	// new state expects data  }  if (WiiCamera_State>=2)	// Waiting for first Data byte from a previous read request  {    WiiCamera_State++;		// new state, now reading data	/*while(Wire.available() && idx < 16)	{        data_buf[idx] = Wire.read();        idx++;	}	*///not sure how to rewrite this block	// if we have 16 bytes of data	if (idx >= 16)	{	    Blob[0].X= data_buf[1];        Blob[0].Y = data_buf[2];        s   = data_buf[3];        Blob[0].X+= (s & 0x30) <<4;        Blob[0].Y += (s & 0xC0) <<2;        Blob[0].Size = (s & 0x0F);		if (Blob[0].Size<15) blobcount++;        Blob[1].X = data_buf[4];        Blob[1].Y = data_buf[5];        s   = data_buf[6];        Blob[1].X += (s & 0x30) <<4;        Blob[1].Y += (s & 0xC0) <<2;        Blob[1].Size = (s & 0x0F);		if (Blob[1].Size<15) blobcount++;        Blob[2].X = data_buf[7];        Blob[2].Y = data_buf[8];        s   = data_buf[9];        Blob[2].X += (s & 0x30) <<4;        Blob[2].Y += (s & 0xC0) <<2;        Blob[2].Size = (s & 0x0F);		if (Blob[2].Size<15) blobcount++;        Blob[3].X = data_buf[10];        Blob[3].Y = data_buf[11];        s   = data_buf[12];        Blob[3].X += (s & 0x30) <<4;        Blob[3].Y += (s & 0xC0) <<2;        Blob[3].Size = (s & 0x0F);		if (Blob[3].Size<15) blobcount++;		WiiCamera_State = 1;				// back to ready to Read state	}	if (WiiCamera_State>=10) WiiCamera_State = 1;	// Waited too long for data - back to ready to Read state }return(blobcount);}